<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D CFD Viewer</title>
    <style>
        body { margin: 0; font-family: 'Inter', sans-serif; background-color: #f0f0f0; color: #333; overflow: hidden; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 1rem;
            box-sizing: border-box;
            background-color: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid #ddd;
        }
        .controls-container {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            align-items: center;
            justify-content: center;
        }
        .control {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 150px;
        }
        label {
            font-size: 0.8rem;
            margin-bottom: 0.25rem;
        }
        input[type="range"] {
            width: 120px;
        }
        button {
            padding: 0.5rem 1rem;
            border: none;
            background-color: #007bff;
            color: white;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #0056b3;
        }
        .legend {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 8px;
            display: none; /* Hidden by default */
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            border: 1px solid #ccc;
            background: linear-gradient(to right, green, orange, red);
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>

    <div id="info">
        <div class="controls-container">
            <div class="control">
                <label for="width">Width: <span id="width-value">5</span>m</label>
                <input type="range" id="width" min="1" max="20" value="5" step="1">
            </div>
            <div class="control">
                <label for="height">Height: <span id="height-value">10</span>m</label>
                <input type="range" id="height" min="1" max="50" value="10" step="1">
            </div>
            <div class="control">
                <label for="depth">Depth: <span id="depth-value">5</span>m</label>
                <input type="range" id="depth" min="1" max="20" value="5" step="1">
            </div>
            <button id="cfd-toggle">Toggle Wind Analysis</button>
        </div>
    </div>

    <div id="legend" class="legend">
        <div class="legend-item">
            <div class="legend-color"></div>
            <span>Low â†’ High Speed</span>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // --- Basic Scene Setup ---
        let scene, camera, renderer, controls;
        let buildingGroup;
        let windLinesGroup;
        let cfdEnabled = false;
        const windFlowLines = [];
        const FLOOR_HEIGHT = 3.5;
        const PATH_CONTROL_POINTS = 50;
        const LINE_RESOLUTION = 200;

        const widthSlider = document.getElementById('width');
        const heightSlider = document.getElementById('height');
        const depthSlider = document.getElementById('depth');
        const widthValue = document.getElementById('width-value');
        const heightValue = document.getElementById('height-value');
        const depthValue = document.getElementById('depth-value');
        const cfdToggleButton = document.getElementById('cfd-toggle');
        const legend = document.getElementById('legend');

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(-40, 25, 40);
            camera.lookAt(0, 10, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 10, 0);
            controls.enableDamping = true;

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(50, 80, 50);
            scene.add(directionalLight);
            
            const groundGeo = new THREE.PlaneGeometry(150, 150);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0xe0e0e0, side: THREE.DoubleSide });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground);

            updateBuilding();

            widthSlider.addEventListener('input', onSliderChange);
            heightSlider.addEventListener('input', onSliderChange);
            depthSlider.addEventListener('input', onSliderChange);
            cfdToggleButton.addEventListener('click', toggleCFD);
            window.addEventListener('resize', onWindowResize, false);

            animate();
        }

        function updateBuilding() {
            if (buildingGroup) {
                scene.remove(buildingGroup);
                buildingGroup.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
            }
            
            buildingGroup = new THREE.Group();
            
            const width = parseFloat(widthSlider.value);
            const height = parseFloat(heightSlider.value);
            const depth = parseFloat(depthSlider.value);

            const massingGeo = new THREE.BoxGeometry(width, height, depth);
            const massingMat = new THREE.MeshStandardMaterial({
                color: 0x007bff,
                transparent: true,
                opacity: 0.5,
                depthWrite: false
            });
            const massingMesh = new THREE.Mesh(massingGeo, massingMat);
            massingMesh.position.y = height / 2;
            buildingGroup.add(massingMesh);

            const lineMat = new THREE.LineBasicMaterial({ color: 0x333333, transparent: true, opacity: 0.7 });
            const numFloors = Math.floor(height / FLOOR_HEIGHT);
            for (let i = 1; i <= numFloors; i++) {
                const y = i * FLOOR_HEIGHT;
                if (y < height) {
                    const points = [
                        new THREE.Vector3(-width / 2, y, -depth / 2),
                        new THREE.Vector3(width / 2, y, -depth / 2),
                        new THREE.Vector3(width / 2, y, depth / 2),
                        new THREE.Vector3(-width / 2, y, depth / 2),
                        new THREE.Vector3(-width / 2, y, -depth / 2)
                    ];
                    const lineGeo = new THREE.BufferGeometry().setFromPoints(points);
                    const floorLine = new THREE.Line(lineGeo, lineMat);
                    buildingGroup.add(floorLine);
                }
            }
            scene.add(buildingGroup);
            
            createWindFlow();
        }

        function calculateControlPoints(startY, startZ, buildingBox) {
            const controlPointsData = [];
            let currentPos = new THREE.Vector3(70, startY, startZ);
            const bHeight = buildingBox.max.y;
            const bDepth = buildingBox.max.z - buildingBox.min.z;
            const stepSize = 140 / PATH_CONTROL_POINTS;

            for (let i = 0; i < PATH_CONTROL_POINTS; i++) {
                let speedFactor = 1.0;
                let velocity = new THREE.Vector3(-stepSize, 0, 0); 

                const influenceBox = buildingBox.clone().expandByScalar(10); // Zone of influence

                if (influenceBox.containsPoint(currentPos)) {
                    const distToSurfaceY = currentPos.y - buildingBox.max.y;
                    const distToSurfaceZ = Math.abs(currentPos.z) - bDepth / 2;

                    // Deflect over the top
                    if (currentPos.y < bHeight && distToSurfaceY < 10) {
                        const push = Math.pow(1 - (distToSurfaceY / 10), 2) * 0.3 * stepSize;
                        velocity.y += push;
                        speedFactor += push * 1.5;
                    }
                    
                    // Deflect around the sides
                    if (distToSurfaceZ < 10) {
                         const push = Math.pow(1 - (distToSurfaceZ / 10), 2) * 0.4 * stepSize;
                         velocity.z += (currentPos.z > 0 ? 1 : -1) * push;
                         speedFactor += push * 2.0;
                    }
                }
                
                // Wake zone
                if (currentPos.x < buildingBox.min.x && currentPos.x > buildingBox.min.x - 30 && currentPos.y < bHeight) {
                   if (Math.abs(currentPos.z) < bDepth) {
                       speedFactor *= 0.4; // Slow down in the wake
                   }
                }
                
                currentPos.add(velocity);

                // Final check to prevent any accidental entry
                if (buildingBox.containsPoint(currentPos)) {
                    buildingBox.clampPoint(currentPos, currentPos);
                }
                
                controlPointsData.push({ point: currentPos.clone(), speed: speedFactor });
            }
            return controlPointsData;
        }

        function createWindFlow() {
            if (windLinesGroup) {
                scene.remove(windLinesGroup);
                windLinesGroup.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
            }
            windLinesGroup = new THREE.Group();
            windFlowLines.length = 0;
            
            const buildingBox = new THREE.Box3().setFromObject(buildingGroup);
            const bDepth = buildingBox.max.z - buildingBox.min.z;
            const windFieldWidth = bDepth + 50;
            const lineCount = 150;

            for (let i = 0; i < lineCount; i++) {
                const startY = Math.random() * 40;
                const startZ = (Math.random() - 0.5) * windFieldWidth;
                
                const controlPointsData = calculateControlPoints(startY, startZ, buildingBox);
                const controlPoints = controlPointsData.map(d => d.point);
                const controlSpeeds = controlPointsData.map(d => d.speed);

                const curve = new THREE.CatmullRomCurve3(controlPoints);
                const pathPoints = curve.getPoints(LINE_RESOLUTION);
                
                const staticColors = [];
                const green = new THREE.Color(0x00ff00);
                const orange = new THREE.Color(0xffa500);
                const red = new THREE.Color(0xff0000);

                for (let j = 0; j < pathPoints.length; j++) {
                    const t = j / (pathPoints.length - 1);
                    const controlIndex = Math.floor(t * (controlSpeeds.length - 1));
                    const nextControlIndex = Math.min(controlIndex + 1, controlSpeeds.length - 1);
                    const segmentT = (t * (controlSpeeds.length - 1)) - controlIndex;
                    const speed = controlSpeeds[controlIndex] * (1 - segmentT) + controlSpeeds[nextControlIndex] * segmentT;

                    const color = new THREE.Color();
                    if (speed > 1.4) {
                        // Interpolate between orange and red
                        const amount = Math.min((speed - 1.4) / 0.5, 1.0); // Normalize between 1.4 and 1.9
                        color.copy(orange).lerp(red, amount);
                    } else if (speed > 1.1) {
                        // Interpolate between green and orange
                        const amount = (speed - 1.1) / 0.3; // Normalize between 1.1 and 1.4
                        color.copy(green).lerp(orange, amount);
                    } else {
                        color.copy(green);
                    }
                    staticColors.push(color);
                }

                const geometry = new THREE.BufferGeometry().setFromPoints(pathPoints);
                const colors = new Float32Array(pathPoints.length * 3);
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const material = new THREE.LineBasicMaterial({ vertexColors: true, transparent: true, opacity: 0.7 });
                const line = new THREE.Line(geometry, material);
                
                const lineObject = {
                    line: line,
                    staticColors: staticColors,
                    flowOffset: Math.floor(Math.random() * pathPoints.length)
                };

                windFlowLines.push(lineObject);
                windLinesGroup.add(line);
            }
            windLinesGroup.visible = cfdEnabled;
            scene.add(windLinesGroup);
        }
        
        function updateWind() {
            if (!cfdEnabled || !windLinesGroup) return;

            windFlowLines.forEach(lineObj => {
                lineObj.flowOffset = (lineObj.flowOffset + 1) % lineObj.staticColors.length;
                
                const colorAttribute = lineObj.line.geometry.attributes.color;
                
                for (let i = 0; i < lineObj.staticColors.length; i++) {
                    const sourceIndex = (i + lineObj.flowOffset) % lineObj.staticColors.length;
                    const color = lineObj.staticColors[sourceIndex];
                    if (color) {
                        colorAttribute.setXYZ(i, color.r, color.g, color.b);
                    }
                }
                
                colorAttribute.needsUpdate = true;
            });
        }

        function onSliderChange() {
            widthValue.textContent = widthSlider.value;
            heightValue.textContent = heightSlider.value;
            depthValue.textContent = depthSlider.value;
            updateBuilding();
        }

        function toggleCFD() {
            cfdEnabled = !cfdEnabled;
            windLinesGroup.visible = cfdEnabled;
            legend.style.display = cfdEnabled ? 'block' : 'none';
            cfdToggleButton.textContent = cfdEnabled ? 'Stop Analysis' : 'Start Wind Analysis';
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            if (cfdEnabled) {
                updateWind();
            }
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
